Biographies/Autobiographies
Conference Proceedings
General Literary Works
Hardwired control
Microprogrammed logic arrays
Writable control store
Automatic synthesis
Formal models
Simulation
Diagnostics
Error-checking
Redundant design
Test generation
Firmware engineering
Languages and compilers
Machine-independent microcode generation
Optimization
Verification
Direct data manipulation
Firmware support of operating systems/instruction sets
Instruction set interpretation
Peripheral control
Special-purpose
Emerging technologies
Calculator
Parallel
Pipeline
Multiple valued logic
Simulation
Verification
Worst-case analysis
Diagnostics
Error-checking
Redundant design
Test generation
Algorithms
Cost/performance
DRAM
ROM
SRAM
Associative memories
Cache memories
Interleaved memories
Mass storage
Primary memory
Sequential-access memory
Shared memory
Virtual memory
Formal models
Simulation
Worst-case analysis
Diagnostics
Error-checking
Redundant design
Test generation
Processors
Receivers
Transmitters
Channels and controllers
Data terminals and printers
Image display
Voice
Asynchronous/synchronous operation
Fiber optics
Interfaces
Parallel I/O
Physical structures
Topology
Web technologies
Wireless systems
Formal models
Simulation
Verification
Worst-case analysis
Built-in tests
Diagnostics
Error-checking
Hardware reliability
Redundant design
Test generation
Arithmetic and logic units
Control design
Data-path design
Memory design
Styles
Automatic synthesis
Hardware description languages
Optimization
Simulation
Verification
Built-in tests
Error-checking
Redundant design
Test generation
Testability
Cellular arrays and automata
Combinational logic
Logic arrays
Memory control and access
Memory used as logic
Parallel circuits
Sequential circuits
Built-in tests
Error-checking
Redundant design
Test generation
Testability
Automatic synthesis
Hardware description languages
Optimization
Simulation
Switching theory
Verification
Advanced technologies
Algorithms implemented in hardware
Gate arrays
Input/output circuits
Memory technologies
Microprocessors and microcomputers
Network connectivity chips
Standard cells
VLSI
Graphics
Layout
Placement and routing
Simulation
Verification
Built-in tests
Error-checking
Fault injection
Redundant design
Test generation
Testability
Design management
Emerging technologies
Hardware/software interfaces
Instruction set design
Modeling of computer architecture
System architectures, integration and modeling
Systems specification methodology
MISD processors
Pipeline processors
RISC/CISC, VLIW architectures
SISD processors
Von Neumann architectures
Array and vector processors
Associative processors
Connection machines
Interconnection architectures
Load balancing and task assignment
MIMD processors
Parallel processors
Pipeline processors
TC scheduling and synchronization
SIMD processors
Adaptable architectures
Analog computers
Capability architectures
Cellular architecture
Dataflow architectures
Heterogeneous (hybrid) systems
High-level language architectures
Multithreaded processors
Neural nets
Neurocomputers
Pipeline processors
Stack-oriented processors
Distributed architectures
Mobile processors
Real-time distributed
Scheduling and task partitioning
Analog computers
Hybrid systems
Architecture
Data communications
Emerging technologies
Infrastructure protection
Interprocessor communications
Network-level security and protection
OSI reference model
Standards
ATM
Centralized networks
Circuit-switching networks
Distributed networks
Frame relay networks
ISDN
Network communications
Network topology
Packet-switching networks
Store and forward networks
Wireless communication
Applications
Protocol architecture
Protocol verification
Routing protocols
Network management
Network monitoring
Public networks
Client/server
Distributed applications
Distributed databases
Network operating systems
Access schemes
Buses
Ethernet
High-speed
Internet
Token rings
Bridges
Gateways
Multicast
Protocols
Routers
Standards
CATV
Optical fiber
Sensor networks
Telephony
Wireless
Algorithm/protocol design and analysis
Architectures
Mobile communication systems
Mobile environments
Support services
Application studies resulting in better multiple-processor systems
Microprocessor/microcomputer applications
Process control systems
Real-time and embedded systems
Reconfigurable hardware
Signal processing systems
Smartcards
Ubiquitous computing
Design studies
Fault tolerance
Measurement techniques
Modeling techniques
Performance attributes
Reliability, availability, and serviceability
Measurement, evaluation, modeling, simulation of multiple-processor systems
Super (very large) computers
Microprocessors
Personal computers
Portable devices
Workstations
Impact of VLSI on system design
Web server
Web browser
Protection mechanisms
Software psychology
Software engineering for Internet projects
Standards
Surveys of historical development of one particular area
Analysis
Elicitation methods
Languages
Management
Methodologies
Process
Specification
Tools
Validation
CASE
Decision tables
Distributed/Internet based software engineering tools and techniques
Modules and interfaces
Programmer workbench
Object-oriented programming
Pretty printers
Program editors
Reentrant code
Standards
Structured programming
Top-down programming
Assertion checkers, assertion languages, performance
Class invariants
Correctness proofs
Formal methods
Model checking
Programming by contract
Reliability
Statistical methods
Validation
Code inspections and walkthroughs
Debugging aids
Diagnostics
Distributed debugging
Dumps
Error handling and recovery
Monitors
Reliability
Symbolic execution
Test levels
Testing strategies
Test design
Test coverage of code
Test coverage of specifications
Test execution
Test documentation
Test management
Testing tools
Tracing
Usability testing
Environments for multiple-processor systems
Graphical environments
Integrated environments
Interactive environments
Programmer workbench
Conversion from sequential to parallel forms
Corrections
Documentation
Enhancement
Evolving Internet applications
Extensibility
Maintainability
Maintenance management
Maintenance measurement
Maintenance planning
Maintenance process
Portability
Restructuring, reverse engineering, and reengineering
Version control
Complexity measures
Performance measures
Process metrics
Product metrics
Software science
Copyrights
Cost estimation
Enactment
Initiation and scope definition
Organizational management and coordination
Planning
Postclosure activities
Productivity
Programming teams
Project close out
Project control &amp; modeling
Review and evaluation
Risk management
Schedule and organizational issues
Software acquisition
Time estimation
Design concepts
Design notations and documentation
Representation
State diagrams
Evolutionary prototyping
Methodologies
Object-oriented design methods
Quality analysis and evaluation
Rapid prototyping
Representation
Data abstraction
Domain-specific architectures
Information hiding
Languages
Patterns
Data mapping
Distributed objects
Interface definition languages
Domain engineering
Reusable libraries
Reuse models
User interfaces
Configuration auditing
Configuration control
Configuration identification
Configuration management process
Configuration status accounting
Software release management and delivery
Construction planning
Code design
Code tuning
Data design and management
Error processing
Source code organization
Code documentation
Construction QA
Programming paradigms
System integration and implementation
Life cycle
Process infrastructure
Process measurement
Process definition
Software process models
Qualitative process analysis
Process implementation and change
Quality concepts
Planning for SQA and V&amp;V
Methods for SQA and V&amp;V
Measurement applied to SQA and V&amp;V
Software libraries
System issues
Standards
Semantics
Syntax
Applicative (functional) languages
Componentware
Compression technologies
Concurrent, distributed, and parallel languages
Constraint and logic languages
Dataflow languages
Design languages
Development tools
Extensible languages
Java
Macro and assembly languages
Microprogramming languages
Multiparadigm languages
Nondeterministic languages
Nonprocedural languages
Object-oriented languages
Query languages
Scripting languages
Specialized application languages
Very high-level languages
Abstract data types
Classes and objects
Concurrent programming structures
Constraints
Control structures
Coroutines
Data types and structures
Distributed objects, components, containers
Dynamic storage management
Frameworks
Inheritance
Input/output
Modules, packages
Patterns
Polymorphism
Procedures, functions, and subroutines
Recursion
Code generation
Compilers
Debuggers
Incremental compilers
Interpreters
Memory management
Optimization
Parsing
Preprocessors
Retargetable compilers
Runtime environments
Translator writing systems and compile
Concurrency
Deadlocks
Multiprocessing/multiprogramming/multitasking
Mutual exclusion
Scheduling
Synchronization
Threads
Allocation/deallocation strategies
Distributed memories
Garbage collection
Main memory
Secondary storage
Segmentation
Storage hierarchies
Swapping
Virtual memory
Access methods
Directory structures
Distributed file systems
File organization
Maintenance
Buffering
Input/output
Message sending
Network communication
Terminal management
Backup procedures
Checkpoint/restart
Disconnected operation
Fault-tolerance
High availability
Verification
Access controls
Authentication
Cryptographic controls
Information flow controls
Invasive software
Security kernels
Verification
Batch processing systems
Distributed systems
Hierarchical design
Interactive systems
Real-time systems and embedded systems
Parallel systems
Measurements
Modeling and prediction
Monitors
Operational analysis
Queuing theory
Simulation
Stochastic analysis
Command and control languages
Linkers
Loaders
Window managers
Application-aware adaptation
Application-transparent adaptation
Fidelity, agility, and stability
Low-bandwidth operation
Transcoding
Data communications aspects
Data dependencies
Data encryption
File organization
Knowledge and data engineering tools and techniques
System applications and experience
Arrays
Distributed data structures
Distributed file systems
Graphs and networks
Lists, stacks, and queues
Records
Tables
Trees
Composite structures
Contiguous representations
Hash-table representations
Linked representations
Object representation
Primitive data items
Code breaking
DES
Public key cryptosystems
Standards
Data compaction and compression
Error control codes
Normal models of communication
Nonsecret encoding schemes
Backup/recovery
Optimization
Organization/structure
Sorting/searching
Automata
Bounded-action devices
Computability theory
Relations between models
Self-modifying machines
Unbounded-action devices
Alternation and nondeterminism
Interactive and reactive computation
Online computation
Parallelism and concurrency
Probabilistic computation
Relations among modes
Relativized computation
Complexity hierarchies
Machine-independent complexity
Reducibility and completeness
Relations among complexity classes
Relations among complexity measures
Computation of transforms
Computations in finite fields
Computations on matrices
Computations on polynomials
Number-theoretic computations
Complexity of proof procedures
Computations on discrete structures
Geometrical problems and computations
Pattern matching
Routing and layout
Sequencing and scheduling
Assertions
Invariants
Logics of programs
Mechanical verification
Pre- and post-conditions
Specification techniques
Algebraic approaches to semantics
Denotational semantics
Operational semantics
Partial evaluation
Process models
Program analysis
Control primitives
Functional constructs
Object-oriented constructs
Program and recursion schemes
Type structure
Computability theory
Computational logic
Lambda calculus and related systems
Logic and constraint programming
Mechanical theorem proving
Modal logic
Model theory
Proof theory
Recursive function theory
Set theory
Temporal logic
Decision problems
Grammar types
Parallel rewriting systems
Parsing
Thue systems
Algebraic language theory
Classes defined by grammars or automata
Classes defined by resource-bounded automata
Decision problems
Operations on languages
Computer arithmetic
Conditioning and ill-conditioning
Error analysis
Interval arithmetic
Multiple precision arithmetic
Numerical algorithms
Parallel algorithms
Stability and instability
Difference formulas
Extrapolation
Interpolation formulas
Smoothing
Spline and piecewise polynomial interpolation
Approximation of surfaces and contours
Chebyshev approximation and theory
Elementary function approximation
Fast Fourier transforms
Least squares approximation
Linear approximation
Minimax approximation and algorithms
Nonlinear approximation
Rational approximation
Special function approximations
Spline and piecewise polynomial approximation
Wavelets and fractals
Conditioning
Determinants
Eigenvalues and eigenvectors
Error analysis
Linear systems
Matrix inversion
Pseudoinverses
Singular value decomposition
Sparse, structured, and very large systems
Adaptive and iterative quadrature
Automatic differentiation
Equal interval integration
Error analysis
Finite difference methods
Gaussian quadrature
Iterative methods
Multidimensional (multiple) quadrature
Continuation (homotopy) methods
Convergence
Error analysis
Iterative methods
Polynomials, methods for
Systems of equations
Constrained optimization
Convex programming
Global optimization
Gradient methods
Inter programming
Least squares methods
Linear programming
Nonlinear programming
Quadratic programming methods
Simulated annealing
Stochastic programming
Unconstrained optimization
Boundary value problems
Chaotic systems
Convergence and stability
Differential-algebraic equations
Error analysis
Finite difference methods
Initial value problems
Multistep and multivalue methods
One-step (single step) methods
Stiff equations
Domain decomposition methods
Elliptic equations
Finite difference methods
Finite element methods
Finite volume methods
Hyperbolic equations
Inverse problems
Iterative solution techniques
Method of lines
Multigrid and multilevel methods
Parabolic equations
Spectral methods
Delay equations
Fredholm equation
Intro-differential equations
Volterra equations
Combinatorial algorithms
Counting problems
Generating functions
Permutations and combinations
Recurrences and difference equations
Graph algorithms
Graph labeling
Hypergraphs
Network problems
Path and circuit problems
Trees
Contingency table analysis
Correlation and regression analysis
Distribution functions
Experimental design
Markov processes
Multivariate statistics
Nonparametric statistics
Probabilistic algorithms
Queuing theory
Random number generation
Reliability and life testing
Renewal theory
Robust regression
Statistical computing
Statistical software
Stochastic processes
Survival analysis
Time series analysis
Algorithm design and analysis
Certification and testing
Documentation
Efficiency
Parallel and vector implementations
Portability
Reliability and robustness
User interfaces
Verification
Queuing theory
Infrastructure Protection
General systems theory
Information theory
Value of information
Human factors
Human-centered computing
Human information processing
Software psychology
Security, integrity, and protection
Database design, modeling and management
Query design and implementation languages
Data models
Database architectures
Database integration
Database models
Normal forms
Schema and subschema
Access methods
Deadlock avoidance
Indexing methods
Physical database design prototypes
Recovery and restart
Data description languages
Data manipulation languages
Database (persistent) programming languages
Database semantics
Query languages
Report writers
Active databases
Buffer management
Concurrency
Distributed databases
Multimedia databases
Object-oriented databases
Parallel databases
Query processing
Relational database
Rule-based databases
Spatial databases
Statistical databases
Temporal databases
Textual databases
Transaction processing
Workflow management
Data translation
Program translation
Data dictionary/directory
Data warehouse and repository
Logging and recovery
Security, integrity, and protection
Bioinformatics (genome or protein) databases
Clustering, classification, and association rules
Data and knowledge visualization
Data mining
Feature extraction or construction
Knowledge management applications
Image databases
Interactive data exploration and discovery
Mining methods and algorithms
Modeling structured, textual and multimedia data
Personalization
Text mining
Web mining
Scientific databases
Spatial databases and GIS
Statistical databases
Web Search
Abstracting methods
Dictionaries
Indexing methods
Linguistic processing
Thesauruses
Document/file management
File organization
Record classification
Storage/repositories
Clustering
Information filtering
Internet search
Metadata
Query formulation
Relevance feedback
Retrieval models
Search process
Selection process
Current awareness systems
Distributed systems
Information networks
Performance evaluation
Question-answering systems
User profiles and alert services
Commercial services
Data sharing
DOM
HTML/DHTML CSS
Web-based services
XML/XSL/RDF
Large text archives
Collection
Dissemination
Standards
Systems issues
User issues
Desktop publishing
Equipment
Groupware
Spreadsheets
Time management
Word processing
Workflow management
Decision support
Logistics
Bulletin boards
Computer conferencing, teleconferencing, and videoconferencing
Electronic mail
Information browsers
Videotex
Animations
Artificial, augmented, and virtual realities
Audio input/output
Evaluation/methodology
Hypertext navigation and maps
Image/video retrieval
Video
Auditory (non-speech) feedback
Benchmarking
Design for wearability
Ergonomics
Evaluation/methodology
Graphical user interfaces
Haptic I/O
Input devices and strategies
Interaction styles
Natural language
Prototyping
Screen design
Standardization
Style guides
Theory and methods
Training, help, and documentation
User-centered design
User interface management systems
Vision I/O
Voice I/O
Windowing systems
Asynchronous interaction
Collaborative computing
Computer-supported cooperative work
Evaluation/methodology
Organizational design
Synchronous interaction
Theory and models
Web-based interaction
Architectures
Navigation
Theory
User issues
Methodologies and techniques
Modeling
Signal analysis, synthesis, and processing
Systems
Representations
Simplification of expressions
Algebraic algorithms
Algorithms for data and knowledge management
Analysis of algorithms
Nonalgebraic algorithms
Performance evaluation of algorithms and systems
Evaluation strategies
Nonprocedural languages
Special-purpose algebraic systems
Special-purpose hardware
Substitution mechanisms
Cognitive simulation
Philosophical foundations
Cartography
Computer vision
Decision support
Education
Environment
Games and infotainment
Industrial automation
Law
Mathematics
Medicine and science
Military
Natural language interfaces
Office automation
Space
Transportation
Automatic analysis of algorithms
Program modification
Program synthesis
Program transformation
Program verification
Answer/reason extraction
Constraint-based processing
Deduction
Inference engines
Logic processing
Logic programming
Mathematical induction
Metatheory
Nonmonotonic reasoning and belief revision
Resolution
Rule-based processing
Uncertainty, &quot;fuzzy,&quot; and probabilistic reasoning
Agent communication languages
Distributed representations
Frames and scripts
Knowledge base management
Knowledge base verification
Modal logic
Predicate logic
Relation systems
Representation languages
Representations (procedural and rule-based)
Semantic networks
Storage mechanisms
Temporal logic
Expert and knowledge-intensive system tools and techniques
Analogies
Concept learning
Connectionism and neural nets
Heuristics design
Induction
Knowledge acquisition
Machine learning
Language acquisition
Parameter learning
Discourse
Language generation
Language models
Language parsing and understanding
Language summarization
Machine translation
Speech recognition and synthesis
Text analysis
Web text analysis
Backtracking
Constraint satisfaction
Control theory
Dynamic programming
Graph and tree search strategies
Heuristic methods
Plan execution, formation, and generation
Scheduling
Autonomous vehicles
Biorobotics
Commercial robots and applications
Kinematics and dynamics
Manipulators
Nanorobots
Neuromorphic computing
Operator interfaces
Propelling mechanisms
Sensors
Workcell organization and planning
Vision
3D/stereo scene analysis
Architecture and control structures
Intensity, color, photometry, and thresholding
Modeling and recovery of physical attributes
Motion
Perceptual reasoning
Representations, data structures, and transforms
Shape
Texture
Video analysis
Coherence and coordination
Intelligent agents
Languages and structures
Multiagent systems
Intelligent Web service languages
Internet reasoning services
Ontology design
Ontology languages
Knowledge acquisition
Knowledge engineering methodologies
Knowledge life cycles
Knowledge maintenance
Knowledge modeling
Knowledge personalization and customization
Knowledge publishing
Knowledge retrieval
Knowledge reuse
Knowledge valuation
Adaptive hypermedia
Computational neuroscience
Evolutionary computing and genetic algorithms
Wearable AI
Graphics processors
Hardcopy devices
Input devices
Parallel processing
Raster display devices
Storage devices
Three-dimensional displays
Vector display devices
Distributed/network graphics
Remote systems
Stand-alone systems
Antialiasing
Bitmap and frame buffer operations
Digitizing and scanning
Display algorithms
Image-based rendering
Line and curve generation
Viewing algorithms
Application packages
Device drivers
Graphics editors
Graphics packages
Meta files
Paint systems
Picture description languages
Software support
Virtual device interfaces
Boundary representations
Constructive solid geometry
Curve, surface, solid, and object representations
Geometric algorithms, languages, and systems
Hierarchy and geometric transformations
Modeling packages
Modeling from video
Object hierarchies
Physically based modeling
Splines
Device independence
Ergonomics
Graphics data structures and data types
Interaction techniques
Languages
Standards
Animation
Color, shading, shadowing, and texture
Fractals
Hidden line/surface removal
Radiosity
Raytracing
Virtual reality
Visible line/surface algorithms
Image displays
Image processing software
Camera calibration
Imaging geometry
Quantization
Radiometry
Reflectance
Sampling
Scanning
Approximate methods
Exact coding
Model-based coding
MP-4 and MP-7
Video coding
Filtering
Geometric correction
Grayscale manipulation
Registration
Sharpening and deblurring
Smoothing
Inverse filtering
Kalman filtering
Pseudoinverse restoration
Wiener filtering
Series expansion methods
Summation methods
Transform methods
Edge and feature detection
Graph-theoretic methods
Markov random fields
Pixel classification
Region growing, partitioning
Relaxation
Stochastic methods
Feature representation
Invariants
Moments
Projections
Size and shape
Texture
Color
Depth cues
Image models
Motion
Object recognition
Photometry
Range data
Sensor fusion
Shading
Shape
Stereo
Surface fitting
Time-varying imagery
Tracking
Hierarchical
Morphological
Multidimensional
Statistical
Volumetric
Deterministic
Fuzzy set
Geometric
Neural nets
Statistical
Structural
Syntactic
Classifier design and evaluation
Feature evaluation and selection
Pattern analysis
Algorithms
Similarity measures
Arts
Computer vision
Computational models of vision
Face and gesture recognition
Government
Handwriting analysis
Industry
Medicine
Military
Remote sensing
Robotics
Sciences
Signal processing
Text processing
Waveform analysis
Interactive systems
Real-time systems
Special architectures
Model classification
Systems theory
Types of simulation
Modeling methodologies
Environments
Animation
Combined
Continuous
Discrete event
Distributed
Gaming
Monte Carlo
Parallel
Visual
Applications
Flow visualization
Information visualization
Multivariate visualization
Visual programming and program visualization
Visualization systems and software
Visualization techniques and methodologies
Volume visualization
Document management
Languages
Spelling
Version control
Desktop publishing
Format and notation
Hypertext/hypermedia
Index generation
Languages and systems
Markup languages
Multi/mixed media
Photocomposition/typesetting
Scripting languages
Standards
Document analysis
Document indexing
Graphics recognition and interpretation
Optical character recognition
Scanning
Business
Education
Financial
Government
Law
Manufacturing
Marketing
Military
Aerospace
Archaeology
Astronomy
Chemistry
Earth and atmospheric sciences
Electronics
Engineering
Mathematics and statistics
Physics
Biology and genetics
Health
Medical information systems
Economics
Psychology
Sociology
Architecture
Arts, fine and performing
Fine arts
Language translation
Linguistics
Literature
Music
Performing arts
Computer-aided design
Computer-aided manufacturing
Command and control
Consumer products
Industrial control
Military
Process control
Publishing
Real time
Client/server and multitier systems
Databases
Database connectivity
Distributed file systems
Electronic commerce
Engineering design
Games
Health care
Intranet/extranet/VPNs
Libraries/information repositories/publishing
Manufacturing
Middleware/business logic
Network repositories/data mining/backup
Software engineering
Traffic analysis
Transaction software
Web browsers
Web servers
Web site management/development tools
Location-dependent and sensitive
Nomadic computing
Multimedia applications and multimedia signal processing
Pervasive computing
Wearable computers and body area networks
Wireless sensor networks
Markets
Standards
Statistics
Suppliers
Hardware
People
Software
Systems
Theory
Collaborative learning
Computer-assisted instruction
Computer-managed instruction
Distance learning
Accreditation
Computer science education
Curriculum
Information systems education
Literacy
Self-assessment
Accreditation
Computer literacy
Abuse and crime involving computers
Computer-related health issues
Ethics
Human safety
Intellectual property rights
Privacy
Regulation
Transborder data flow
Use/abuse of power
Abuse and crime involving computers
Assistive technologies for persons with disabilities
Employment
Handicapped persons/special needs
Automation
Computer-supported collaborative work
Deployment, usage experience
Employment
Reengineering
Scalability, maintainability
Cybercash, digital cash
Distributed commercial transactions
Electronic data interchange
Intellectual property
Payment schemes
Security
Internet security policies
Mobile code security
Economic and other policies
Copyrights
Licensing
Patents
Proprietary rights
Trade secrets
Censorship
Regulation
Taxation
Contracts
Hardware patents
Economics
Information resource management
Life cycle
Management techniques
Staffing
Strategic information systems planning
Systems analysis and design
Systems development
Training
Benchmarks
Computer selection
Computing equipment management
Performance and usage measurement
Pricing and resource allocation
Software development
Software maintenance
Software process
Software selection
Centralization/decentralization
Management audit
Quality assurance
Authentication
Insurance
Invasive software (viruses, worms, Trojan horses)
Physical security
Unauthorized access (hacking, phreaking)
Insurance
Security
Career Management
Codes of ethics
Codes of good practice
Ethical dilemmas
Codes of good practice
Ethics
Games
Data communications
Database processing
Freeware/shareware
Graphics
Spreadsheets
Word processing
Business
Education
Financial
Healthcare
Industrial
IT Applications
Legal
Library
Military
Publishing
Sports